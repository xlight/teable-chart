1. Get the application URL by running these commands:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "teable.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
{{- else if contains "LoadBalancer" .Values.service.type }}
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "teable.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "teable.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  echo http://$SERVICE_IP:{{ .Values.service.port }}
{{- else if contains "ClusterIP" .Values.service.type }}
  export POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "app.kubernetes.io/name={{ include "teable.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace {{ .Release.Namespace }} port-forward $POD_NAME 8080:$CONTAINER_PORT
{{- end }}

2. Check the status of your Teable deployment:
   kubectl get pods -l "app.kubernetes.io/name={{ include "teable.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -n {{ .Release.Namespace }}

3. View application logs:
   kubectl logs -l "app.kubernetes.io/name={{ include "teable.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -n {{ .Release.Namespace }}

4. To check the health of your application:
   kubectl exec -it deployment/{{ include "teable.fullname" . }} -n {{ .Release.Namespace }} -- curl -v localhost:3000/health

{{- if .Values.minio.enabled }}

5. MinIO Configuration:
   - MinIO Console URL: Access via port-forward or ingress
   - Default credentials: {{ .Values.minio.rootUser }} / {{ .Values.minio.rootPassword }}
   - Buckets created: {{ .Values.storage.publicBucket }} (public), {{ .Values.storage.privateBucket }} (private)

   To access MinIO console:
   kubectl port-forward svc/{{ .Release.Name }}-minio 9001:9001 -n {{ .Release.Namespace }}
   Then visit: http://127.0.0.1:9001
{{- end }}

{{- if .Values.postgres.enabled }}

6. PostgreSQL Configuration:
   - Database: {{ .Values.postgresql.auth.database }}
   - Username: postgres
   - Password: {{ .Values.postgresql.auth.postgresPassword }}

   To connect to PostgreSQL:
   kubectl port-forward svc/{{ .Release.Name }}-postgresql 5432:5432 -n {{ .Release.Namespace }}
{{- end }}

{{- if .Values.redis.enabled }}

7. Redis Configuration:
   Redis is running internally and accessible at: {{ .Release.Name }}-redis-master:6379
{{- end }}

Important Notes:
- Make sure to update the publicOrigin in values.yaml to match your actual domain
- Update JWT and session secrets in values.yaml for production use
- Configure proper TLS certificates for production deployment
- Ensure MinIO buckets have correct permissions (public bucket should be publicly readable)
- Monitor resource usage and adjust limits accordingly

For troubleshooting, check:
- Pod status: kubectl describe pod -l "app.kubernetes.io/name={{ include "teable.name" . }}" -n {{ .Release.Namespace }}
- ConfigMap: kubectl describe configmap {{ include "teable.fullname" . }}-config -n {{ .Release.Namespace }}
- Secret: kubectl describe secret {{ include "teable.fullname" . }}-secret -n {{ .Release.Namespace }}
